
!  +++++++++++++++++++++++ BOXTETRA_ROUTINES ++++++++++++++++++++++++++

MODULE BOXTETRA_ROUTINES
USE PRECISION_PARAMETERS
USE MATH_FUNCTIONS, ONLY: CROSS_PRODUCT
IMPLICIT NONE

PRIVATE

INTEGER, DIMENSION(0:3,0:5), TARGET :: BOX_PLANE2VERT
INTEGER, DIMENSION(0:3,0:5), TARGET :: BOX_PLANE2EDGE
INTEGER, DIMENSION(0:1,0:11), TARGET :: BOX_EDGE2VERT

INTEGER, DIMENSION(0:2,0:3), TARGET :: TETRA_PLANE2VERT
INTEGER, DIMENSION(0:2,0:3), TARGET :: TETRA_PLANE2EDGE
INTEGER, DIMENSION(0:1,0:5) :: TETRA_EDGE2VERT

REAL(EB), DIMENSION(0:2,0:5), TARGET :: BOX_NORMALS
REAL(EB), DIMENSION(0:2,0:3), TARGET :: TETRA_NORMALS, TETRA_VERTS
REAL(EB), DIMENSION(0:2,0:7), TARGET :: BOX_VERTS

REAL(EB), DIMENSION(0:5) :: TETRA_BOUNDS
REAL(EB), DIMENSION(0:5,0:3),TARGET :: TETRA_PLANE_BOUNDS
REAL(EB), DIMENSION(0:5,0:5),TARGET :: BOX_PLANE_BOUNDS

INTEGER, PARAMETER :: MIN_X=0, MAX_X=1, MIN_Y=2, MAX_Y=3, MIN_Z=4, MAX_Z=5

INTEGER :: I, J

DATA ( (BOX_NORMALS(I,J), I=0,2),J=0,5) /&
  -1.0_EB,  0.0_EB,  0.0_EB,&
   1.0_EB,  0.0_EB,  0.0_EB,&
   0.0_EB,-1.0_EB,   0.0_EB,&
   0.0_EB,  1.0_EB,  0.0_EB,&
   0.0_EB,  0.0_EB, -1.0_EB,&
   0.0_EB,  0.0_EB,  1.0_EB&
  /

DATA ( (BOX_PLANE2VERT(I,J), I=0,3),J=0,5) /&
  0,2,4,6,&
  1,3,5,7,&
  0,1,4,5,&
  2,3,6,7,&
  0,1,2,3,&
  4,5,6,7 &
  /
  
DATA ( (BOX_PLANE2EDGE(I,J), I=0,3),J=0,5) /&
  0,2,8,10,&
  1,3,9,11,&
  4,6,8,9,&
  5,7,10,11,&
  0,1,4,5,&
  2,3,6,7 &
  /
  
 DATA ( (BOX_EDGE2VERT(I,J), I=0,1), J=0,11) /&
  0,2,  1,3,  4,6,  5,7,&
  0,1,  2,3,  4,5,  6,7,&
  0,4,  1,5,  2,6,  3,7&
  /
  
DATA ( (TETRA_PLANE2VERT(I,J), I=0,2),J=0,3) /&
  0,3,1,&
  1,3,2,&
  0,2,3,&
  0,1,2&
  /
  
DATA ( (TETRA_PLANE2EDGE(I,J), I=0,2),J=0,3) /&
  0,3,4,&
  1,4,5,&
  2,3,5,&
  0,1,2&
  /
  
 DATA ( (TETRA_EDGE2VERT(I,J), I=0,1), J=0,5) /&
  0,1,  1,2,  2,0,&
  0,3,  1,3,  2,3&
  /

PUBLIC GET_TETRABOX_VOLUME, GET_VERTS, VOLUME_VERTS

CONTAINS

!  ------------------ GET_TETRABOX_VOLUME ------------------------ 

REAL(EB) FUNCTION GET_TETRABOX_VOLUME(BOX_BOUNDS,V0,V1,V2,V3,CUT_CELL_VOLUME)

! compute the volume of the intersection of a box and a tetrahedron

REAL(EB), DIMENSION(0:5), INTENT(IN) :: BOX_BOUNDS
REAL(EB), DIMENSION(0:2), INTENT(IN) :: V0, V1, V2, V3
REAL(EB), INTENT(OUT) :: CUT_CELL_VOLUME

REAL(EB), DIMENSION(0:299) :: VERTS
INTEGER :: NVERTS, NFACES
INTEGER, DIMENSION(0:99) :: FACESTART, FACENUM
REAL(EB) :: DX, DY, DZ

! obtain vertices of intersection region

CALL GET_VERTS(BOX_BOUNDS,V0,V1,V2,V3,VERTS,NVERTS,FACESTART,FACENUM,NFACES)

! compute volume using computed vertices

GET_TETRABOX_VOLUME = GET_POLYHEDRON_VOLUME(VERTS,NVERTS,FACESTART,FACENUM,NFACES)
DX = BOX_BOUNDS(1)-BOX_BOUNDS(0)
DY = BOX_BOUNDS(3)-BOX_BOUNDS(2)
DZ = BOX_BOUNDS(5)-BOX_BOUNDS(4)
CUT_CELL_VOLUME = DX*DY*DZ - GET_TETRABOX_VOLUME

RETURN
END FUNCTION GET_TETRABOX_VOLUME

!  ------------------ VOLUME_VERTS ------------------------ 

!              D1 
!             /|\  
!            / | \
!           /  |  \  
!          /   |   \  
!         /    |    \ 
!        /     B4    \
!       /     . .     \
!      /     .    .    \   
!     /    .        .   \
!    /   .            .  \    
!   /  .               .  \
!  / .                    .\
! C2------------------------A3

REAL(EB) FUNCTION VOLUME_VERTS(A,B,C,D)

! determine the volume of a tetrahedron formed from vertices A, B, C and D

REAL(EB), DIMENSION(0:2), INTENT(IN) :: A, B, C, D
REAL(EB), DIMENSION(0:2) :: AMC, BMC, DMC, ACROSSB

AMC = A - C
BMC = B - C
DMC = D - C
CALL CROSS_PRODUCT(ACROSSB,AMC, BMC)
VOLUME_VERTS = DOT_PRODUCT(ACROSSB,DMC)/6.0_EB
END FUNCTION VOLUME_VERTS

!  ------------------ GET_POLYHEDRON_VOLUME ------------------------ 

REAL(EB) FUNCTION GET_POLYHEDRON_VOLUME(VERTS,NVERTS,FACESTART,FACENUM,NFACES)

REAL(EB), DIMENSION(0:299), INTENT(IN), TARGET :: VERTS
INTEGER, INTENT(IN) :: NVERTS, NFACES
INTEGER, DIMENSION(0:99), INTENT(IN) :: FACESTART, FACENUM

REAL(EB), DIMENSION(0:2) :: V_CENTER
REAL(EB), DIMENSION(:), POINTER :: V0, V1, V2
REAL(EB) :: VOLUME

! compute center of intersection region

V_CENTER=0.0_EB
DO I = 0, NVERTS - 1
   V_CENTER = V_CENTER + VERTS(3*I:3*I+2)
ENDDO
V_CENTER = V_CENTER/NVERTS

! sum volumes of each region formed using polyhedron face and center

VOLUME=0.0_EB
DO I = 0, NFACES-1
   IF (FACENUM(I).LT.3) CYCLE
   J = FACESTART(I)
   V0(0:2) => VERTS(3*J:3*J+2)
   DO J = FACESTART(I)+1, FACESTART(I+1)-2
      V1(0:2) => VERTS(3*J:3*J+2)
      V2(0:2) => VERTS(3*J+3:3*J+5)
      VOLUME = VOLUME + ABS(VOLUME_VERTS(V0,V1,V2,V_CENTER))
   ENDDO
ENDDO

GET_POLYHEDRON_VOLUME = VOLUME

END FUNCTION GET_POLYHEDRON_VOLUME

!  ------------------ GET_VERTS ------------------------ 

SUBROUTINE GET_VERTS(BOX_BOUNDS,VV0,VV1,VV2,VV3,VERTS,NVERTS,FACESTART,FACENUM,NFACES)

! determine vertices of tetrahedron box intersection region ordered by faces

REAL(EB), DIMENSION(0:5), INTENT(IN) :: BOX_BOUNDS
REAL(EB), DIMENSION(0:2), INTENT(IN) :: VV0, VV1, VV2, VV3
REAL(EB), DIMENSION(0:299), INTENT(OUT), TARGET :: VERTS
INTEGER, DIMENSION(0:99), INTENT(OUT) :: FACESTART, FACENUM
INTEGER, INTENT(OUT) :: NVERTS,NFACES

REAL(EB), DIMENSION(0:2) :: VERT
REAL(EB), POINTER, DIMENSION(:) :: BOXVERT, BOXNORMAL,  BOXVERT0, BOXVERT1
REAL(EB), POINTER, DIMENSION(:) :: TETRAVERT, TETRANORMAL, TETRAVERT0, TETRAVERT1
REAL(EB), POINTER, DIMENSION(:) :: FACEVERTS
INTEGER, POINTER, DIMENSION(:) :: EDGE
INTEGER, DIMENSION(0:9) :: NORMAL_INDEX
REAL(EB), DIMENSION(:), POINTER :: B_PLANE_BOUNDS, T_PLANE_BOUNDS

INTEGER :: V,E,F,BP,BE,BV,TP,TE,TV

REAL(EB), DIMENSION(0:2) :: V0, V1, V2, V3, VC

! setup data structures

V0=VV0
V1=VV1
V2=VV2
V3=VV3
CALL SETUP_VERTS(BOX_BOUNDS,V0,V1,V2,V3)

! swap vertices if orientation is reversed

VC=(V0+V1+V2+V3)/4.0_EB
IF (IN_TETRA(VC,-1).EQ.0) THEN
   V0=VV0
   V1=VV2
   V2=VV1
   V3=VV3
   CALL SETUP_VERTS(BOX_BOUNDS,V0,V1,V2,V3)
ENDIF

NVERTS=0
NFACES=0
DO F = 0,99
  FACESTART(F) = 0
  FACENUM(F) = 0
ENDDO

IF(BOX_BOUNDS(1).LT.TETRA_BOUNDS(0))RETURN
IF(BOX_BOUNDS(0).GT.TETRA_BOUNDS(1))RETURN
IF(BOX_BOUNDS(3).LT.TETRA_BOUNDS(2))RETURN
IF(BOX_BOUNDS(2).GT.TETRA_BOUNDS(3))RETURN
IF(BOX_BOUNDS(5).LT.TETRA_BOUNDS(4))RETURN
IF(BOX_BOUNDS(4).GT.TETRA_BOUNDS(5))RETURN

! determine vertices of intersection region

! for each box plane ...

DO BP = 0, 5 
   V = BOX_PLANE2VERT(0,BP)
   BOXVERT(0:2) => BOX_VERTS(0:2,V)
   BOXNORMAL(0:2) => BOX_NORMALS(0:2,BP)
   B_PLANE_BOUNDS(0:5) => BOX_PLANE_BOUNDS(0:5,BP)

!  add intersection of tetrahedron edge and box plane (if on box)

   DO TE = 0, 5 ! tetra edge
      TETRAVERT0(0:2) => TETRA_VERTS(0:2,TETRA_EDGE2VERT(0,TE))
      TETRAVERT1(0:2) => TETRA_VERTS(0:2,TETRA_EDGE2VERT(1,TE))
      IF (B_PLANE_BOUNDS(0).GT.MAX(TETRAVERT0(0),TETRAVERT1(0))) CYCLE
      IF (B_PLANE_BOUNDS(1).LT.MIN(TETRAVERT0(0),TETRAVERT1(0))) CYCLE
      IF (B_PLANE_BOUNDS(2).GT.MAX(TETRAVERT0(1),TETRAVERT1(1))) CYCLE
      IF (B_PLANE_BOUNDS(3).LT.MIN(TETRAVERT0(1),TETRAVERT1(1))) CYCLE
      IF (B_PLANE_BOUNDS(4).GT.MAX(TETRAVERT0(2),TETRAVERT1(2))) CYCLE
      IF (B_PLANE_BOUNDS(5).LT.MIN(TETRAVERT0(2),TETRAVERT1(2))) CYCLE
      IF ( BOXPLANE_EDGE_INTERSECTION( BOXVERT,BP,TETRAVERT0,TETRAVERT1,VERT).NE.1) CYCLE
      IF ( IN_BOX(VERT, BP).NE.1) CYCLE

      VERTS(3*NVERTS:3*NVERTS+2)=VERT(0:2)
      FACENUM(NFACES) = FACENUM(NFACES) + 1
      NVERTS=NVERTS+1
   ENDDO

!  add intersection of box plane edge and tetrahedron plane (if on tetrahedron)
  
   EDGE(0:3) => BOX_PLANE2EDGE(0:3,BP)
   DO BE = 0, 3 ! box plane edges
      E = EDGE(BE)
      BOXVERT0(0:2) => BOX_VERTS(0:2,BOX_EDGE2VERT(0,E))
      BOXVERT1(0:2) => BOX_VERTS(0:2,BOX_EDGE2VERT(1,E))
      DO TP = 0, 3 ! tetra plane
         T_PLANE_BOUNDS(0:5) => TETRA_PLANE_BOUNDS(0:5,TP)
         IF (T_PLANE_BOUNDS(0).GT.MAX(BOXVERT0(0),BOXVERT1(0))) CYCLE
         IF (T_PLANE_BOUNDS(1).LT.MIN(BOXVERT0(0),BOXVERT1(0))) CYCLE
         IF (T_PLANE_BOUNDS(2).GT.MAX(BOXVERT0(1),BOXVERT1(1))) CYCLE
         IF (T_PLANE_BOUNDS(3).LT.MIN(BOXVERT0(1),BOXVERT1(1))) CYCLE
         IF (T_PLANE_BOUNDS(4).GT.MAX(BOXVERT0(2),BOXVERT1(2))) CYCLE
         IF (T_PLANE_BOUNDS(5).LT.MIN(BOXVERT0(2),BOXVERT1(2))) CYCLE
         V = TETRA_PLANE2VERT(0,TP)
         TETRAVERT(0:2) => TETRA_VERTS(0:2,V)
         TETRANORMAL(0:2) => TETRA_NORMALS(0:2,TP)
         IF ( PLANE_EDGE_INTERSECTION( TETRAVERT,TETRANORMAL,BOXVERT0,BOXVERT1,VERT).EQ.1) THEN
            IF (IN_TETRA(VERT, TP) .EQ. 1) THEN
               VERTS(3*NVERTS:3*NVERTS+2)=VERT(0:2)
               FACENUM(NFACES) = FACENUM(NFACES) + 1
               NVERTS=NVERTS+1
            ENDIF
         ENDIF
      ENDDO
   ENDDO

! add box plane vertices if inside tetrahedron

   DO BV = 0, 3
      BOXVERT(0:2) => BOX_VERTS(0:2,BOX_PLANE2VERT(BV,BP))
      IF (IN_TETRA(BOXVERT, -1) .EQ. 1) THEN
         VERTS(3*NVERTS:3*NVERTS+2)=BOXVERT(0:2)
         FACENUM(NFACES) = FACENUM(NFACES) + 1
         NVERTS=NVERTS+1
      ENDIF
   ENDDO
   
   IF(FACENUM(NFACES).GT.0) THEN
      NORMAL_INDEX(NFACES) = BP
      NFACES = NFACES + 1
   ENDIF

ENDDO

! for each tetrahedron plane ....

DO TP = 0, 3
   V = TETRA_PLANE2VERT(0,TP)
   TETRAVERT(0:2) => TETRA_VERTS(0:2,V)
   TETRANORMAL(0:2) => TETRA_NORMALS(0:2,TP)
   T_PLANE_BOUNDS(0:5) => TETRA_PLANE_BOUNDS(0:5,TP)

!  add intersection of box edge and tetrahedron plane (if on tetrahedron)

   DO BE = 0, 11 ! box edge
      BOXVERT0(0:2) => BOX_VERTS(0:2,BOX_EDGE2VERT(0,BE))
      BOXVERT1(0:2) => BOX_VERTS(0:2,BOX_EDGE2VERT(1,BE))
      IF (T_PLANE_BOUNDS(0).GT.MAX(BOXVERT0(0),BOXVERT1(0))) CYCLE
      IF (T_PLANE_BOUNDS(1).LT.MIN(BOXVERT0(0),BOXVERT1(0))) CYCLE
      IF (T_PLANE_BOUNDS(2).GT.MAX(BOXVERT0(1),BOXVERT1(1))) CYCLE
      IF (T_PLANE_BOUNDS(3).LT.MIN(BOXVERT0(1),BOXVERT1(1))) CYCLE
      IF (T_PLANE_BOUNDS(4).GT.MAX(BOXVERT0(2),BOXVERT1(2))) CYCLE
      IF (T_PLANE_BOUNDS(5).LT.MIN(BOXVERT0(2),BOXVERT1(2))) CYCLE
      IF ( PLANE_EDGE_INTERSECTION( TETRAVERT,TETRANORMAL,BOXVERT0,BOXVERT1,VERT).NE.1) CYCLE
      IF (IN_TETRA(VERT, TP).NE.1) CYCLE

      VERTS(3*NVERTS:3*NVERTS+2)=VERT(0:2)
      FACENUM(NFACES) = FACENUM(NFACES) + 1
      NVERTS=NVERTS+1
   ENDDO

!  add intersection of tetrahedron plane edge and box plane (if on box)
  
   EDGE(0:2) => TETRA_PLANE2EDGE(0:2,TP)
   DO TE = 0, 2 ! tetrahedron plane edges
      E = EDGE(TE)
      TETRAVERT0(0:2) => TETRA_VERTS(0:2,TETRA_EDGE2VERT(0,E))
      TETRAVERT1(0:2) => TETRA_VERTS(0:2,TETRA_EDGE2VERT(1,E))
      DO BP = 0, 5 ! box plane
         B_PLANE_BOUNDS(0:5) => BOX_PLANE_BOUNDS(0:5,BP)
         IF (B_PLANE_BOUNDS(0).GT.MAX(TETRAVERT0(0),TETRAVERT1(0))) CYCLE
         IF (B_PLANE_BOUNDS(1).LT.MIN(TETRAVERT0(0),TETRAVERT1(0))) CYCLE
         IF (B_PLANE_BOUNDS(2).GT.MAX(TETRAVERT0(1),TETRAVERT1(1))) CYCLE
         IF (B_PLANE_BOUNDS(3).LT.MIN(TETRAVERT0(1),TETRAVERT1(1))) CYCLE
         IF (B_PLANE_BOUNDS(4).GT.MAX(TETRAVERT0(2),TETRAVERT1(2))) CYCLE
         IF (B_PLANE_BOUNDS(5).LT.MIN(TETRAVERT0(2),TETRAVERT1(2))) CYCLE
         V = BOX_PLANE2VERT(0,BP)
         BOXVERT(0:2) => BOX_VERTS(0:2,V)
         BOXNORMAL(0:2) => BOX_NORMALS(0:2,BP)
         IF ( BOXPLANE_EDGE_INTERSECTION( BOXVERT,BP,TETRAVERT0,TETRAVERT1,VERT).NE.1) CYCLE
         IF (IN_BOX(VERT, BP) .NE. 1) CYCLE

         VERTS(3*NVERTS:3*NVERTS+2)=VERT(0:2)
         FACENUM(NFACES) = FACENUM(NFACES) + 1
         NVERTS=NVERTS+1
      ENDDO
   ENDDO

! add tetrahedron plane vertices if inside box

   DO TV = 0, 2
      TETRAVERT(0:2) => TETRA_VERTS(0:2,TETRA_PLANE2VERT(TV,TP))
      IF (IN_BOX(TETRAVERT, -1) .EQ. 1) THEN
         VERTS(3*NVERTS:3*NVERTS+2)=TETRAVERT(0:2)
         FACENUM(NFACES) = FACENUM(NFACES) + 1
         NVERTS=NVERTS+1
      ENDIF
   ENDDO
   
   IF(FACENUM(NFACES).GT.0) THEN
      NORMAL_INDEX(NFACES) = 6+TP
      NFACES = NFACES + 1
   ENDIF

ENDDO

! determine vertex index at the start of each face

DO F = 1, NFACES
  FACESTART(F) = FACESTART(F-1) + FACENUM(F-1)
ENDDO

! order vertices of each face clockwise

DO F = 0, NFACES-1
  IF(FACENUM(F).LE.3) CYCLE
  FACEVERTS(0:3*FACENUM(F)-1) => VERTS(3*FACESTART(F):3*FACESTART(F+1)-1)
  CALL ORDER_VERTS(FACEVERTS,FACENUM(F),NORMAL_INDEX(F))
ENDDO

RETURN
END SUBROUTINE GET_VERTS

!  ------------------ COMPARE_VERTS ------------------------ 

INTEGER FUNCTION COMPARE_VERTS(A,B,C,N)

! determine orientation of vertices A, B, C relative to vector N

REAL(EB), DIMENSION(0:2), INTENT(IN) :: A, B, C, N
REAL(EB), DIMENSION(0:2) :: AMC, BMC, ACROSSB
REAL(EB) :: VAL

AMC = A - C
BMC = B - C
CALL CROSS_PRODUCT(ACROSSB,AMC, BMC)
VAL = DOT_PRODUCT(ACROSSB,N)/6.0_EB
IF (VAL.GT.0.0_EB) THEN
  COMPARE_VERTS = 1
ELSE IF(VAL.EQ.0.0_EB) THEN
  COMPARE_VERTS = 0
ELSE
  COMPARE_VERTS = -1
ENDIF
END FUNCTION COMPARE_VERTS

!  ------------------ ORDER_VERTS ------------------------ 

SUBROUTINE ORDER_VERTS(FACEVERTS,NVERTS,NORMAL_INDEX)

! order vertices of a given face

INTEGER, INTENT(IN) :: NVERTS, NORMAL_INDEX
REAL(EB), DIMENSION(0:3*NVERTS-1), INTENT(INOUT), TARGET :: FACEVERTS

REAL(EB), DIMENSION(:), POINTER :: NORMAL
REAL(EB), DIMENSION(0:2) :: VERT_CENTER
REAL(EB), DIMENSION(:), POINTER :: VERT, VERT1, VERT2
REAL(EB), DIMENSION(0:3*NVERTS-1) :: FACEVERTS_TEMP
INTEGER :: ORIENTATION
INTEGER :: I, II, IIP1, J
INTEGER, DIMENSION(0:100) :: ORDER
INTEGER :: N_CLOCKWISE, N_COUNTER_CLOCKWISE

! first 6 (starting at 0) normal indices are for box faces
! next 4 (6->9) normal indices are for tetrahedron faces

IF (NORMAL_INDEX.LE.5) THEN
   NORMAL(0:2) => BOX_NORMALS(0:2,NORMAL_INDEX)
ELSE
   NORMAL(0:2) => TETRA_NORMALS(0:2,NORMAL_INDEX-6)
ENDIF

! find center of vertices

VERT_CENTER=0.0_EB
DO I = 0, NVERTS-1
  VERT(0:2) => FACEVERTS(3*I:3*I+2)
  VERT_CENTER = VERT_CENTER + VERT
ENDDO
VERT_CENTER = VERT_CENTER/REAL(NVERTS,EB)

! split vertices into two parts
!    those before and those after vertex 0

N_CLOCKWISE=0
N_COUNTER_CLOCKWISE=0
VERT1(0:2) => FACEVERTS(0:2)
DO I = 1, NVERTS-1
  VERT2(0:2) => FACEVERTS(3*I:3*I+2)
  ORIENTATION=COMPARE_VERTS(VERT1,VERT2,VERT_CENTER,NORMAL)
  IF (ORIENTATION.GE.1) THEN
    ORDER(NVERTS-1-N_CLOCKWISE) = I
    N_CLOCKWISE = N_CLOCKWISE + 1
  ELSE
    ORDER(N_COUNTER_CLOCKWISE) = I
    N_COUNTER_CLOCKWISE = N_COUNTER_CLOCKWISE + 1
  ENDIF
ENDDO
ORDER(N_COUNTER_CLOCKWISE) = 0

! order vertices that are counter clockwise from vertex 0

IF (N_COUNTER_CLOCKWISE.GT.1) THEN
   DO J = 0, N_COUNTER_CLOCKWISE - 1
   DO I = 0, N_COUNTER_CLOCKWISE - 2
      II = ORDER(I)
      VERT1(0:2) => FACEVERTS(3*II:3*II+2)
      IIP1 = ORDER(I+1)
      VERT2(0:2) => FACEVERTS(3*IIP1:3*IIP1+2)
      ORIENTATION=COMPARE_VERTS(VERT1,VERT2,VERT_CENTER,NORMAL)
      IF (ORIENTATION.LT.1) THEN
         ORDER(I) = IIP1
         ORDER(I+1) = II
      ENDIF
   ENDDO
   ENDDO
ENDIF

! order vertices that are counter clockwise from vertex 0

IF (N_CLOCKWISE.GT.1) THEN
   DO J = 0, N_CLOCKWISE - 1
   DO I = 0, N_CLOCKWISE - 2
      II = ORDER(N_COUNTER_CLOCKWISE+1+I)
      VERT1(0:2) => FACEVERTS(3*II:3*II+2)
      IIP1 = ORDER(N_COUNTER_CLOCKWISE+1+I+1)
      VERT2(0:2) => FACEVERTS(3*IIP1:3*IIP1+2)
      ORIENTATION=COMPARE_VERTS(VERT1,VERT2,VERT_CENTER,NORMAL)
      IF (ORIENTATION.LT.1) THEN
         ORDER(N_COUNTER_CLOCKWISE+1+I) = IIP1
         ORDER(N_COUNTER_CLOCKWISE+1+I+1) = II
      ENDIF
   ENDDO
   ENDDO
ENDIF

! copy ordered vertices into original data structure

FACEVERTS_TEMP(0:3*NVERTS-1) = FACEVERTS(0:3*NVERTS-1)
DO I = 0, NVERTS-1
   FACEVERTS(3*I:3*I+2) = FACEVERTS_TEMP(3*ORDER(I):3*ORDER(I)+2)
ENDDO

END SUBROUTINE ORDER_VERTS

!  ------------------ SETUP_VERTS ------------------------ 

SUBROUTINE SETUP_VERTS(BOX_BOUNDS,V0,V1,V2,V3)
REAL(EB), DIMENSION(0:5), INTENT(IN) :: BOX_BOUNDS
REAL(EB), DIMENSION(0:2), INTENT(IN) :: V0, V1, V2, V3
REAL(EB), DIMENSION(0:2) :: VDIFF1, VDIFF2, VCROSS
INTEGER :: TP, BP
INTEGER, DIMENSION(:), POINTER :: VERTS

! define box vertices given x/y/z min/max values

BOX_VERTS(0,0) = BOX_BOUNDS(MIN_X)
BOX_VERTS(1,0) = BOX_BOUNDS(MIN_Y)
BOX_VERTS(2,0) = BOX_BOUNDS(MIN_Z)

BOX_VERTS(0,1) = BOX_BOUNDS(MAX_X)
BOX_VERTS(1,1) = BOX_BOUNDS(MIN_Y)
BOX_VERTS(2,1) = BOX_BOUNDS(MIN_Z)

BOX_VERTS(0,2) = BOX_BOUNDS(MIN_X)
BOX_VERTS(1,2) = BOX_BOUNDS(MAX_Y)
BOX_VERTS(2,2) = BOX_BOUNDS(MIN_Z)

BOX_VERTS(0,3) = BOX_BOUNDS(MAX_X)
BOX_VERTS(1,3) = BOX_BOUNDS(MAX_Y)
BOX_VERTS(2,3) = BOX_BOUNDS(MIN_Z)

BOX_VERTS(0,4) = BOX_BOUNDS(MIN_X)
BOX_VERTS(1,4) = BOX_BOUNDS(MIN_Y)
BOX_VERTS(2,4) = BOX_BOUNDS(MAX_Z)

BOX_VERTS(0,5) = BOX_BOUNDS(MAX_X)
BOX_VERTS(1,5) = BOX_BOUNDS(MIN_Y)
BOX_VERTS(2,5) = BOX_BOUNDS(MAX_Z)

BOX_VERTS(0,6) = BOX_BOUNDS(MIN_X)
BOX_VERTS(1,6) = BOX_BOUNDS(MAX_Y)
BOX_VERTS(2,6) = BOX_BOUNDS(MAX_Z)

BOX_VERTS(0,7) = BOX_BOUNDS(MAX_X)
BOX_VERTS(1,7) = BOX_BOUNDS(MAX_Y)
BOX_VERTS(2,7) = BOX_BOUNDS(MAX_Z)

TETRA_BOUNDS(0) = MIN(V0(0),V1(0),V2(0),V3(0))
TETRA_BOUNDS(1) = MAX(V0(0),V1(0),V2(0),V3(0))
TETRA_BOUNDS(2) = MIN(V0(1),V1(1),V2(1),V3(1))
TETRA_BOUNDS(3) = MAX(V0(1),V1(1),V2(1),V3(1))
TETRA_BOUNDS(4) = MIN(V0(2),V1(2),V2(2),V3(2))
TETRA_BOUNDS(5) = MAX(V0(2),V1(2),V2(2),V3(2))

DO TP = 0, 3
  VERTS(0:2) => TETRA_PLANE2VERT(0:2,TP)
  TETRA_PLANE_BOUNDS(0,TP) = MIN(TETRA_VERTS(0,VERTS(0)),TETRA_VERTS(0,VERTS(1)),TETRA_VERTS(0,VERTS(2)))
  TETRA_PLANE_BOUNDS(1,TP) = MAX(TETRA_VERTS(0,VERTS(0)),TETRA_VERTS(0,VERTS(1)),TETRA_VERTS(0,VERTS(2)))
  TETRA_PLANE_BOUNDS(2,TP) = MIN(TETRA_VERTS(1,VERTS(0)),TETRA_VERTS(1,VERTS(1)),TETRA_VERTS(1,VERTS(2)))
  TETRA_PLANE_BOUNDS(3,TP) = MAX(TETRA_VERTS(1,VERTS(0)),TETRA_VERTS(1,VERTS(1)),TETRA_VERTS(1,VERTS(2)))
  TETRA_PLANE_BOUNDS(4,TP) = MIN(TETRA_VERTS(2,VERTS(0)),TETRA_VERTS(2,VERTS(1)),TETRA_VERTS(2,VERTS(2)))
  TETRA_PLANE_BOUNDS(5,TP) = MAX(TETRA_VERTS(2,VERTS(0)),TETRA_VERTS(2,VERTS(1)),TETRA_VERTS(2,VERTS(2)))
ENDDO

DO BP = 0, 5
  VERTS(0:3) => BOX_PLANE2VERT(0:3,BP)
  BOX_PLANE_BOUNDS(0,BP) = MIN(BOX_VERTS(0,VERTS(0)),BOX_VERTS(0,VERTS(1)),BOX_VERTS(0,VERTS(2)),BOX_VERTS(0,VERTS(3)))
  BOX_PLANE_BOUNDS(1,BP) = MAX(BOX_VERTS(0,VERTS(0)),BOX_VERTS(0,VERTS(1)),BOX_VERTS(0,VERTS(2)),BOX_VERTS(0,VERTS(3)))
  BOX_PLANE_BOUNDS(2,BP) = MIN(BOX_VERTS(1,VERTS(0)),BOX_VERTS(1,VERTS(1)),BOX_VERTS(1,VERTS(2)),BOX_VERTS(0,VERTS(3)))
  BOX_PLANE_BOUNDS(3,BP) = MAX(BOX_VERTS(1,VERTS(0)),BOX_VERTS(1,VERTS(1)),BOX_VERTS(1,VERTS(2)),BOX_VERTS(0,VERTS(3)))
  BOX_PLANE_BOUNDS(4,BP) = MIN(BOX_VERTS(2,VERTS(0)),BOX_VERTS(2,VERTS(1)),BOX_VERTS(2,VERTS(2)),BOX_VERTS(0,VERTS(3)))
  BOX_PLANE_BOUNDS(5,BP) = MAX(BOX_VERTS(2,VERTS(0)),BOX_VERTS(2,VERTS(1)),BOX_VERTS(2,VERTS(2)),BOX_VERTS(0,VERTS(3)))
ENDDO

! define tetrahedron vertices

TETRA_VERTS(0:2,0) = V0
TETRA_VERTS(0:2,1) = V1
TETRA_VERTS(0:2,2) = V2
TETRA_VERTS(0:2,3) = V3

! compute normals for each tetrahedron face

VDIFF1 = V0 - V3
VDIFF2 = V1 - V3
CALL CROSS_PRODUCT(VCROSS,VDIFF1,VDIFF2)
TETRA_NORMALS(0:2,0)=VEC_NORMALIZE(VCROSS)

VDIFF1 = V1 - V3
VDIFF2 = V2 - V3
CALL CROSS_PRODUCT(VCROSS,VDIFF1,VDIFF2)
TETRA_NORMALS(0:2,1)=VEC_NORMALIZE(VCROSS)

VDIFF1 = V0 - V2
VDIFF2 = V3 - V2
CALL CROSS_PRODUCT(VCROSS,VDIFF1,VDIFF2)
TETRA_NORMALS(0:2,2)=VEC_NORMALIZE(VCROSS)

VDIFF1 = V0 - V1
VDIFF2 = V2 - V1
CALL CROSS_PRODUCT(VCROSS,VDIFF1,VDIFF2)
TETRA_NORMALS(0:2,3)=VEC_NORMALIZE(VCROSS)

RETURN
END SUBROUTINE SETUP_VERTS

!  ------------------ PLANE_EDGE_INTERSECTION ------------------------ 

INTEGER FUNCTION PLANE_EDGE_INTERSECTION(X0,N0,V0,V1,VERT)

! PLANE: (X-X0).DOT.N0 = 0, EDGE: V0->V1

! find T such that ( (1-T)*V0 + T*V1 - X0 ) .DOT. N0 = 0
! if V1-V0 is perpendicular to N0 ie (V1-V0).DOT.N0 = 0 then there is no solution

REAL(EB), DIMENSION(0:2), INTENT(IN) :: X0, N0, V0, V1
REAL(EB), DIMENSION(0:2), INTENT(OUT) :: VERT
REAL(EB), DIMENSION(0:2) :: V1MV0, V0MX0

REAL(EB) :: DENOM, T

PLANE_EDGE_INTERSECTION=0

V1MV0 = V1-V0
V0MX0 = V0-X0
DENOM = DOT_PRODUCT(V1MV0,N0)
IF (DENOM.NE.0) THEN
   T = -DOT_PRODUCT(V0MX0,N0)/DENOM
   IF (T.GE.0.0_EB.AND.T.LE.1.0_EB) THEN
      PLANE_EDGE_INTERSECTION=1
      VERT = V0 + T*V1MV0
   ENDIF
ENDIF
RETURN
END FUNCTION PLANE_EDGE_INTERSECTION

!  ------------------ BOXPLANE_EDGE_INTERSECTION ------------------------ 

INTEGER FUNCTION BOXPLANE_EDGE_INTERSECTION(X0,PLANE,V0,V1,VERT)

! PLANE: (X-X0).DOT.N0 = 0, EDGE: V0->V1

! find T such that ( (1-T)*V0 + T*V1 - X0 ) .DOT. N0 = 0
! if V1-V0 is perpendicular to N0 ie (V1-V0).DOT.N0 = 0 then there is no solution

REAL(EB), DIMENSION(0:2), INTENT(IN) :: X0, V0, V1
INTEGER, INTENT(IN) :: PLANE
REAL(EB), DIMENSION(0:2), INTENT(OUT) :: VERT
REAL(EB), DIMENSION(0:2) :: V1MV0, V0MX0

REAL(EB) :: DENOM, T
INTEGER, DIMENSION(0:5) :: PLANE_INDEX

DATA PLANE_INDEX/0,0,1,1,2,2/

BOXPLANE_EDGE_INTERSECTION=0

V1MV0 = V1-V0
V0MX0 = V0-X0
!DENOM = DOT_PRODUCT(V1MV0,N0)
DENOM = V1MV0(PLANE_INDEX(PLANE))
IF (DENOM.NE.0) THEN
!   T = -DOT_PRODUCT(V0MX0,N0)/DENOM
   T = -V0MX0(PLANE_INDEX(PLANE))/DENOM
   IF (T.GE.0.0_EB.AND.T.LE.1.0_EB) THEN
      BOXPLANE_EDGE_INTERSECTION=1
      VERT = V0 + T*V1MV0
   ENDIF
ENDIF
RETURN
END FUNCTION BOXPLANE_EDGE_INTERSECTION

!  ------------------ IN_BOX ------------------------ 

INTEGER FUNCTION IN_BOX(XYZ, IGNORE_PLANE)

! determine if a vertex XYZ is inside the box

REAL(EB), INTENT(IN), DIMENSION(0:2) :: XYZ
INTEGER, INTENT(IN) :: IGNORE_PLANE
  
INTEGER BP
REAL(EB), DIMENSION(0:2) :: VECDIFF
REAL(EB), DIMENSION(:), POINTER :: BOXVERT, BOXNORMAL
  
IN_BOX=1
DO BP = 0, 5
   IF (BP.EQ.IGNORE_PLANE) CYCLE
   BOXVERT(0:2) => BOX_VERTS(0:2,BOX_PLANE2VERT(0,BP))
   BOXNORMAL(0:2) => BOX_NORMALS(0:2,BP)
   VECDIFF = XYZ - BOXVERT
   IF (DOT_PRODUCT(BOXNORMAL,VECDIFF)>0.0_EB) THEN
      IN_BOX=0
      RETURN
   ENDIF
ENDDO
END FUNCTION IN_BOX

!  ------------------ IN_TETRA ------------------------ 

INTEGER FUNCTION IN_TETRA(XYZ, IGNORE_PLANE)

! determine if a vertex XYZ is inside the tetrahedron

REAL(EB), INTENT(IN), DIMENSION(0:2) :: XYZ
INTEGER, INTENT(IN) :: IGNORE_PLANE
REAL(EB), DIMENSION(0:2) :: VECDIFF
REAL(EB), DIMENSION(:), POINTER :: TETRAVERT, TETRANORMAL

INTEGER :: TP
  
IN_TETRA=1
DO TP = 0, 3
   IF (TP.EQ.IGNORE_PLANE) CYCLE
   TETRAVERT(0:2) => TETRA_VERTS(0:2,TETRA_PLANE2VERT(0,TP))
   TETRANORMAL(0:2) => TETRA_NORMALS(0:2,TP)
   VECDIFF = XYZ - TETRAVERT
   IF (DOT_PRODUCT(TETRANORMAL,VECDIFF)>0.0_EB) THEN
      IN_TETRA=0
      RETURN
   ENDIF
ENDDO
END FUNCTION IN_TETRA

!  ------------------ VEC_NORMALIZE ------------------------ 

FUNCTION VEC_NORMALIZE(U)

! normalize a vector so |U|=1

REAL(EB), DIMENSION(0:2) :: VEC_NORMALIZE
REAL(EB), DIMENSION(0:2), INTENT(IN) :: U

REAL(EB) :: SUM

SUM = SQRT(DOT_PRODUCT(U,U))
IF (SUM .NE.0.0_EB) THEN
  VEC_NORMALIZE = U/SUM
ELSE
   VEC_NORMALIZE = U
ENDIF

RETURN
END FUNCTION VEC_NORMALIZE

END MODULE BOXTETRA_ROUTINES
